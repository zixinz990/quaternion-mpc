//
// Created by shuoy on 8/10/21.
//

#include "utils/A1Kinematics.h"

namespace legged {

    Eigen::Vector3d A1Kinematics::fk(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
        Eigen::Vector3d out;
        autoFunc_fk_derive(q.data(), rho_opt.data(), rho_fix.data(), out.data());
        return out;
    }

    Eigen::Matrix3d A1Kinematics::jac(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
        Eigen::Matrix3d mtx;
        autoFunc_d_fk_dq(q.data(), rho_opt.data(), rho_fix.data(), mtx.data());
        return mtx;
    }

    Eigen::Matrix3d A1Kinematics::dfk_drho(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
        Eigen::Matrix3d mtx;
        autoFunc_d_fk_dc(q.data(), rho_opt.data(), rho_fix.data(), mtx.data());
        return mtx;
    }

    Eigen::Matrix<double, 9, 3> A1Kinematics::dJ_dq(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
        Eigen::Matrix<double, 9, 3> mtx;
        autoFunc_dJ_dq(q.data(), rho_opt.data(), rho_fix.data(), mtx.data());
        return mtx;
    }

    Eigen::Matrix<double, 9, 3> A1Kinematics::dJ_drho(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
        Eigen::Matrix<double, 9, 3> mtx;
        autoFunc_dJ_dpho(q.data(), rho_opt.data(), rho_fix.data(), mtx.data());
        return mtx;
    }

    // functions generated by matlab
    void A1Kinematics::autoFunc_fk_derive(const double q[3], const double dq[3], const double
    ddq[5], double p_bf[3]) {
        double p_bf_tmp;
        double t2;
        double t3;
        double t4;
        double t5;
        double t6;
        double t7;
        double t8;
        double t9;

        // This function was generated by the Symbolic Math Toolbox version 8.6.
        // 10-Aug-2021 14:48:21
        t2 = std::cos(q[0]);
        t3 = std::cos(q[1]);
        t4 = std::cos(q[2]);
        t5 = std::sin(q[0]);
        t6 = std::sin(q[1]);
        t7 = std::sin(q[2]);
        t8 = q[1] + q[2];
        t9 = std::sin(t8);
        p_bf[0] = (((ddq[0] + dq[2] * t9) - ddq[4] * t9) - t6 * ddq[3]) + dq[0] *
                                                                           std::cos(t8);
        p_bf[1] = ((((((((ddq[1] + dq[1] * t2) + ddq[2] * t2) + t3 * t5 * ddq[3]) +
                       dq[0] * t3 * t5 * t7) + dq[0] * t4 * t5 * t6) - dq[2] * t3 *
                                                                         t4 * t5) + dq[2] * t5 * t6 * t7) + ddq[4] * t3 * t4 * t5) - ddq
                                                                                                                                      [4] * t5 * t6 * t7;
        t8 = dq[0] * t2;
        t9 = dq[2] * t2;
        p_bf_tmp = ddq[4] * t2;
        p_bf[2] = (((((((dq[1] * t5 + ddq[2] * t5) - t2 * t3 * ddq[3]) - t8 * t3 * t7)
                      - t8 * t4 * t6) + t9 * t3 * t4) - t9 * t6 * t7) - p_bf_tmp * t3 *
                                                                        t4) + p_bf_tmp * t6 * t7;
    }

    void A1Kinematics::autoFunc_d_fk_dq(const double q[3], const double dq[3], const double
    ddq[5], double jacobian[9]) {
        double b_jacobian_tmp;
        double c_jacobian_tmp;
        double jacobian_tmp;
        double t12;
        double t16;
        double t17;
        double t2;
        double t22;
        double t3;
        double t4;
        double t5;
        double t6;
        double t7;
        double t8;
        double t9;

        // This function was generated by the Symbolic Math Toolbox version 8.6.
        // 10-Aug-2021 14:48:21
        t2 = std::cos(q[0]);
        t3 = std::cos(q[1]);
        t4 = std::cos(q[2]);
        t5 = std::sin(q[0]);
        t6 = std::sin(q[1]);
        t7 = std::sin(q[2]);
        t8 = q[1] + q[2];
        t9 = std::cos(t8);
        t8 = std::sin(t8);
        t12 = dq[0] * t9;
        t16 = dq[2] * t8;
        t17 = ddq[4] * t8;
        t22 = (t12 + t16) + -t17;
        jacobian[0] = 0.0;
        jacobian_tmp = dq[0] * t2;
        b_jacobian_tmp = dq[2] * t2;
        c_jacobian_tmp = ddq[4] * t2;
        jacobian[1] = (((((((-dq[1] * t5 - ddq[2] * t5) + t2 * t3 * ddq[3]) +
                           jacobian_tmp * t3 * t7) + jacobian_tmp * t4 * t6) -
                         b_jacobian_tmp * t3 * t4) + b_jacobian_tmp * t6 * t7) +
                       c_jacobian_tmp * t3 * t4) - c_jacobian_tmp * t6 * t7;
        jacobian[2] = (((((((dq[1] * t2 + ddq[2] * t2) + t3 * t5 * ddq[3]) + dq[0] *
                                                                              t3 * t5 * t7) + dq[0] * t4 * t5 * t6) - dq[2] * t3 * t4 *
                                                                                                                       t5) + dq[2] * t5 * t6 * t7) + ddq[4] * t3 * t4 * t5) - ddq[4]
                                                                                                                                                                               * t5 * t6 * t7;
        jacobian_tmp = (dq[2] * t9 + -(ddq[4] * t9)) + -(dq[0] * t8);
        jacobian[3] = jacobian_tmp - t3 * ddq[3];
        b_jacobian_tmp = ((t6 * ddq[3] - t12) - t16) + t17;
        jacobian[4] = -t5 * b_jacobian_tmp;
        jacobian[5] = t2 * b_jacobian_tmp;
        jacobian[6] = jacobian_tmp;
        jacobian[7] = t5 * t22;
        jacobian[8] = -t2 * t22;
    }

    void A1Kinematics::autoFunc_d_fk_dc(const double q[3], const double [3], const double [5],
                                        double d_fk_dc[9]) {
        double t2;
        double t3;
        double t4;
        double t5;

        // This function was generated by the Symbolic Math Toolbox version 8.6.
        // 10-Aug-2021 14:48:21
        t2 = std::cos(q[0]);
        t3 = std::sin(q[0]);
        t4 = q[1] + q[2];
        t5 = std::cos(t4);
        t4 = std::sin(t4);
        d_fk_dc[0] = t5;
        d_fk_dc[1] = t3 * t4;
        d_fk_dc[2] = -t2 * t4;
        d_fk_dc[3] = 0.0;
        d_fk_dc[4] = t2;
        d_fk_dc[5] = t3;
        d_fk_dc[6] = t4;
        d_fk_dc[7] = -t3 * t5;
        d_fk_dc[8] = t2 * t5;
    }

    void A1Kinematics::autoFunc_dJ_dq(const double q[3], const double dq[3], const double ddq[5],
                                      double dJ_dq[27]) {
        double t10;
        double t13;
        double t17;
        double t18;
        double t2;
        double t26;
        double t27;
        double t28;
        double t3;
        double t31;
        double t34;
        double t34_tmp;
        double t35;
        double t4;
        double t5;
        double t6;
        double t7;
        double t8;
        double t9;

        // This function was generated by the Symbolic Math Toolbox version 8.6.
        // 10-Aug-2021 14:48:21
        t2 = std::cos(q[0]);
        t3 = std::cos(q[1]);
        t4 = std::cos(q[2]);
        t5 = std::sin(q[0]);
        t6 = std::sin(q[1]);
        t7 = std::sin(q[2]);
        t8 = q[1] + q[2];
        t9 = std::cos(t8);
        t10 = t3 * ddq[3];
        t8 = std::sin(t8);
        t13 = dq[0] * t9;
        t17 = dq[2] * t8;
        t18 = ddq[4] * t8;
        t9 = (ddq[4] * t9 + dq[0] * t8) + -(dq[2] * t9);
        t8 = (t13 + t17) + -t18;
        t26 = (t18 + -t13) + -t17;
        t27 = t5 * t8;
        t28 = t2 * t9;
        t18 = t2 * t8;
        t31 = t10 + t9;
        t34_tmp = t6 * ddq[3] + t26;
        t34 = -t2 * t34_tmp;
        t35 = -t5 * t34_tmp;
        t8 = -(t5 * t9);
        dJ_dq[0] = 0.0;
        dJ_dq[1] = (((((((-dq[1] * t2 - ddq[2] * t2) - t5 * t10) - dq[0] * t3 * t5 *
                                                                    t7) - dq[0] * t4 * t5 * t6) + dq[2] * t3 * t4 * t5) - dq[2]
                                                                                                                            * t5 * t6 * t7) - ddq[4] * t3 * t4 * t5) + ddq[4] * t5 * t6 * t7;
        t9 = dq[0] * t2;
        t13 = dq[2] * t2;
        t17 = ddq[4] * t2;
        dJ_dq[2] = (((((((-dq[1] * t5 - ddq[2] * t5) + t2 * t10) + t9 * t3 * t7) + t9
                                                                                    * t4 * t6) - t13 * t3 * t4) + t13 * t6 * t7) + t17 * t3 * t4) -
                   t17 * t6 * t7;
        dJ_dq[3] = 0.0;
        dJ_dq[4] = t34;
        dJ_dq[5] = t35;
        dJ_dq[6] = 0.0;
        dJ_dq[7] = t18;
        dJ_dq[8] = t27;
        dJ_dq[9] = 0.0;
        dJ_dq[10] = t34;
        dJ_dq[11] = t35;
        dJ_dq[12] = t34_tmp;
        dJ_dq[13] = -t5 * t31;
        dJ_dq[14] = t2 * t31;
        dJ_dq[15] = t26;
        dJ_dq[16] = t8;
        dJ_dq[17] = t28;
        dJ_dq[18] = 0.0;
        dJ_dq[19] = t18;
        dJ_dq[20] = t27;
        dJ_dq[21] = t26;
        dJ_dq[22] = t8;
        dJ_dq[23] = t28;
        dJ_dq[24] = t26;
        dJ_dq[25] = t8;
        dJ_dq[26] = t28;
    }

    void A1Kinematics::autoFunc_dJ_dpho(const double q[3], const double [3], const double [5],
                                        double dJ_dpho[27]) {
        double t11;
        double t12;
        double t13;
        double t2;
        double t3;
        double t4;
        double t5;
        double t9;

        // This function was generated by the Symbolic Math Toolbox version 8.6.
        // 10-Aug-2021 14:48:22
        t2 = std::cos(q[0]);
        t3 = std::sin(q[0]);
        t4 = q[1] + q[2];
        t5 = std::cos(t4);
        t4 = std::sin(t4);
        t9 = t3 * t5;
        t11 = t3 * t4;
        t12 = -(t2 * t5);
        t13 = t2 * -t4;
        dJ_dpho[0] = 0.0;
        dJ_dpho[1] = t2 * t4;
        dJ_dpho[2] = t11;
        dJ_dpho[3] = -t4;
        dJ_dpho[4] = t9;
        dJ_dpho[5] = t12;
        dJ_dpho[6] = -t4;
        dJ_dpho[7] = t9;
        dJ_dpho[8] = t12;
        dJ_dpho[9] = 0.0;
        dJ_dpho[10] = -t3;
        dJ_dpho[11] = t2;
        dJ_dpho[12] = 0.0;
        dJ_dpho[13] = 0.0;
        dJ_dpho[14] = 0.0;
        dJ_dpho[15] = 0.0;
        dJ_dpho[16] = 0.0;
        dJ_dpho[17] = 0.0;
        dJ_dpho[18] = 0.0;
        dJ_dpho[19] = t12;
        dJ_dpho[20] = -t9;
        dJ_dpho[21] = t5;
        dJ_dpho[22] = t11;
        dJ_dpho[23] = t13;
        dJ_dpho[24] = t5;
        dJ_dpho[25] = t11;
        dJ_dpho[26] = t13;
    }

    inline float A1Kinematics::atan_approx(float x) {
        float a1 = 0.99997726f;
        float a3 = -0.33262347f;
        float a5 = 0.19354346f;
        float a7 = -0.11643287f;
        float a9 = 0.05265332f;
        float a11 = -0.01172120f;
        float x_sq = x * x;
        return x * fmaf(x_sq, fmaf(x_sq, fmaf(x_sq, fmaf(x_sq, fmaf(x_sq, a11, a9), a7), a5), a3), a1);
    }

    float A1Kinematics::atan2_approx(const float y, const float x) {
        float pi = M_PI;
        float pi_2 = M_PI_2;
        bool swap = fabsf(x) < fabsf(y);
        float atan_input = (swap ? x : y) / (swap ? y : x);
        float res = atan_approx(atan_input);
        res = swap ? (atan_input >= 0.0f ? pi_2 : -pi_2) - res : res;
        if (x < 0.0f) { res = (y >= 0.0f ? pi : -pi) + res; }
        return res;
    }

    // Eigen::Vector3d A1Kinematics::inv_kin(Eigen::Vector3d p, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix, Eigen::Vector3d guess) {
    //     Eigen::Vector3d q = guess;
    //     Eigen::Vector3d p_now = fk(q, rho_opt, rho_fix);
    //     double res = (p - p_now).norm();
    //     int max_iter = 100000;
    //     int counter = 0;
    //     double h = 0.01;
    //     while (res > 1e-5) {
    //         Eigen::Vector3d dq = jac(q, rho_opt, rho_fix).transpose() * (p - p_now);
    //         q = q + dq * h;
    //         p_now = fk(q, rho_opt, rho_fix);
    //         res = (p - p_now).norm();
    //         if (counter >= max_iter) {
    //             return Eigen::Vector3d(Eigen::Infinity, Eigen::Infinity, Eigen::Infinity);
    //             break;
    //         }
    //         counter++;
    //     }

    //     return q;
    // }

    Eigen::Vector3d A1Kinematics::inv_kin(Eigen::Vector3d p, Eigen::Vector3d cur_q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
        double ox = rho_fix[0];
        double oy = rho_fix[1];
        double d = rho_fix[2];
        double lt = rho_fix[3];
        double lc = rho_fix[4];

        double Xf = p[0];
        double Yf = p[1];
        double Zf = p[2];

        double Yf_ = Yf - oy;
        double Xf_ = Xf - ox;

        double L_square = Zf * Zf + Yf_ * Yf_ - d * d;
        double L = sqrt(L_square);

        double t1 = 0.0;
        double t1_candidate = 0.0;
        double t2 = 0.0;
        double t3 = 0.0;

        double cur_t1 = cur_q[0];
        double cur_t2 = cur_q[1];
        double cur_t3 = cur_q[2];

        // calculate t1
        if (oy > 0) { // if FL or RL
            if (Zf > 0) { // if the foot position is higher than the torso
                if (Yf_ > 0) {
                    t1 = atan2_approx(Zf, Yf_) - atan2_approx(L, d);
                } else if (Yf_ == 0) {
                    t1 = M_PI / 2 - atan2_approx(L, d);
                } else if (Yf_ < 0) {
                    t1 = M_PI - atan2_approx(Zf, -Yf_) - atan2_approx(L, d);
                }
                // calculate another possible t1
                t1_candidate = atan2_approx(Zf, Yf_) + atan2_approx(L, d);
            } else if (Zf < 0) { // if the foot position is lower than the torso
                if (Yf_ > 0) {
                    t1 = atan2_approx(Zf, Yf_) + atan2_approx(L, d);
                } else if (Yf_ == 0) {
                    t1 = -M_PI / 2 + atan2_approx(L, d);
                } else if (Yf_ < 0) {
                    t1 = -M_PI - atan2_approx(Zf, -Yf_) + atan2_approx(L, d);
                }
                // calculate another possible t1
                t1_candidate = atan2_approx(Zf, Yf_) - atan2_approx(L, d);
            } else {
                t1 = atan2_approx(L, d);
                t1_candidate = -atan2_approx(L, d);
            }

            // compare t1 and t1_candidate
            if (abs(t1 - cur_t1) < abs(t1_candidate - cur_t1)) {
                t1 = t1;
            } else {
                t1 = t1_candidate;
            }
        } else { // if FR or RR
            if (Zf > 0) {
                if (Yf_ < 0) {
                    t1 = -atan2_approx(Zf, -Yf_) + atan2_approx(L, -d);
                } else if (Yf_ == 0) {
                    t1 = -M_PI / 2 + atan2_approx(L, -d);
                } else if (Yf_ > 0) {
                    t1 = -M_PI + atan2_approx(Zf, Yf_) + atan2_approx(L, -d);
                }
                // calculate another possible t1
                t1_candidate = -atan2_approx(L, -d) - atan2_approx(Zf, -Yf_);
            } else if (Zf < 0) {
                if (Yf_ < 0) {
                    t1 = atan2_approx(-Zf, -Yf_) - atan2_approx(L, -d);
                } else if (Yf_ == 0) {
                    t1 = -M_PI / 2 - atan2_approx(L, -d);
                } else if (Yf_ > 0) {
                    t1 = M_PI - atan2_approx(-Zf, Yf_) - atan2_approx(L, -d);
                }
                // calculate another possible t1
                t1_candidate = atan2_approx(-Zf, -Yf_) + atan2_approx(L, -d);
            }

            // compare t1 and t1_candidate
            if (abs(t1 - cur_t1) < abs(t1_candidate - cur_t1)) {
                t1 = t1;
            } else {
                t1 = t1_candidate;
            }
        }

        // calculate t2
        double cos_beta = (lt * lt + lc * lc - Xf_ * Xf_ - L * L) / (2 * lt * lc);
        double beta = 0;
        if (abs(cos_beta + 1) < 0.001) { // if cos_beta is around -1
            beta = M_PI;
        } else if (abs(cos_beta - 1) < 0.001) { // if cos_alpha is around 1
            beta = 0;
        } else {
            beta = std::acos(cos_beta);
        }

        t3 = beta - M_PI;

        // calculate the z position of joint 2
        double joint_2_z = d * sin(t1);
        if (Zf > joint_2_z) {
            L = -L;
        }
        double gamma = atan2_approx(-Xf_, L);
        // std::cout << "gamma = " << gamma << std::endl;

        double alpha = atan2_approx(lc * sin(-t3), lt + lc * cos(-t3));

        t2 = gamma + alpha;

        if (t2 < -60 * M_PI / 180) {
            t2 = t2 + 2 * M_PI;
        } else if (t2 > 240 * M_PI / 180) {
            t2 = t2 - 2 * M_PI;
        }

        Eigen::Vector3d inv_kin_sol;
        inv_kin_sol << t1, t2, t3;
        return inv_kin_sol;
    }
}
